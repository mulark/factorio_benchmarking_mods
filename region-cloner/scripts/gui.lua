local gui = {}

local mod_gui = require("mod-gui")

gui.create_gui = function (player)
    gui.clear_gui(player)
    local mod_button = mod_gui.get_button_flow(player).add{type="sprite-button", name=GUI_PFX .. "main-button", sprite="achievement/lazy-bastard", tooltip="Region Cloner"}
    mod_button.style = mod_gui.button_style
    local frame_flow = mod_gui.get_frame_flow(player)
    local mod_frame = frame_flow.add{type="frame", name=GUI_PFX .. "control-window", caption="", direction="vertical"}

    local title_flow = mod_frame.add{type="flow"}
    local title = title_flow.add{type="label", caption="Region Cloner"}
    title.style.font = "default-large-bold"
    local sub_title = title_flow.add{type="flow"}
    sub_title.style.horizontally_stretchable = true
    sub_title.style.horizontal_align = "right"
    local advanced_view_button = sub_title.add{name=GUI_PFX .. "advanced_view_button", type="button", tooltip="Open advanced settings", caption="Advanced"}

    local advanced_settings_gui = frame_flow.add{name=GUI_PFX .. "advanced_view_pane", type="frame", direction = "vertical"}
    local advanced_title_flow = advanced_settings_gui.add{type="flow"}
    local adv_title = advanced_title_flow.add{type="label", caption="Advanced Settings", tooltip="Break at your own risk."}
    adv_title.style.font = "default-large-bold"
    local sub_adv_title = advanced_title_flow.add{type="flow"}
    sub_adv_title.style.horizontally_stretchable = true
    sub_adv_title.style.horizontal_align = "right"
    sub_adv_title.add{name=GUI_PFX .. "reset_gui_button", type="button", caption="Reset GUI", tooltip="Resets the GUI for your player."}
    advanced_settings_gui.visible = false

    local advanced_tile_paste_lengths_table = advanced_settings_gui.add{type="table", column_count=3, name=GUI_PFX .. "advanced_tile_paste_override_table"}
    advanced_tile_paste_lengths_table.add{type="label"}
    advanced_tile_paste_lengths_table.add{type="label", caption="Tiles to paste X"}
    advanced_tile_paste_lengths_table.add{type="label", caption="Tiles to paste Y"}
    advanced_tile_paste_lengths_table.add{type="checkbox", state=false, name = GUI_PFX .. "advanced_tile_paste_override_checkbox", tooltip="Overrides the tile paste length from being calculated using the bounding box. Useful if you want to partially overlap paste areas. Strongly reccomended to not clear paste area at the same time. Overrides Direction to copy. Allows bad or unusual values so use with care.", caption="Tile paste override"}
    advanced_tile_paste_lengths_table.add{name=GUI_PFX .. "advanced_tile_paste_x", type="textfield", text="0", numeric=true, allow_decimal=true, allow_negative=true}
    advanced_tile_paste_lengths_table.add{name=GUI_PFX .. "advanced_tile_paste_y", type="textfield", text="0", numeric=true, allow_decimal=true, allow_negative=true}

    local clear_paste_area_table = advanced_settings_gui.add{type="table", column_count=3, name=GUI_PFX .. "advanced_clear_paste_area_table"}
    clear_paste_area_table.add{type="label", caption="Clear paste area:", tooltip="Look for entities in the area about to be pasted into and delete them. If you don't clear normal entities it's likely that you'll stack mutiple on one tile, so be careful! Defaults to true."}
    clear_paste_area_table.add{type="checkbox", caption="Normal entities", state=true, name=GUI_PFX .. "clear_normal_entities", tooltip="Clears the paste area of any player owned entities. If you use tile paste overrides with this setting enabled it probably won't work like you want it to!"}
    clear_paste_area_table.add{type="checkbox", caption="Resources", state=true, name=GUI_PFX .. "clear_resource_entities", tooltip="Clears the paste area of ore/resources. May need to pre-generate the map to ensure ore is generated by the time we look for it."}

	--[Adding the "progress bar" checkbox]
	advanced_settings_gui.add{type="checkbox", caption="Print Progress", state=false, name=GUI_PFX .. "progress_bar", tooltip="The progress bar spends an additional 1 tick for each copy, which increases chance of clones breaking."}
	advanced_settings_gui.add{type="checkbox", caption="Print Detailed Progress", state=false, name=GUI_PFX .. "detailed_log", tooltip="The detailed log copies different types of entities in different ticks, which increases the chance of clones breaking."}

    mod_frame.visible = false
    local coord_gui_table = mod_frame.add{type="table", column_count=3, name=GUI_PFX .. "coordinate-table"}
        coord_gui_table.add{type="label", name="left_top_description", caption="Left_top", tooltip="The top left corner coordinate of the region you wish to copy"}
        coord_gui_table.add{type="textfield", name="left_top_x", text="0", numeric=true, allow_negative=true}
        coord_gui_table.add{type="textfield", name="left_top_y", text="0", numeric=true, allow_negative=true}
        coord_gui_table.add{type="label", name="right_bottom_description", caption="Right_bottom", tooltip="The bottom right corner coordinate of the region you wish to copy"}
        coord_gui_table.add{type="textfield", name="right_bottom_x", text="0", numeric=true, allow_negative=true}
        coord_gui_table.add{type="textfield", name="right_bottom_y", text="0", numeric=true, allow_negative=true}

    -- Add selection box rendering controls
    local selection_box_table = mod_frame.add{type="table", column_count=2, name=GUI_PFX .. "selection_box_table"}
        selection_box_table.add{type="checkbox", caption="Show Selection Box", state=true, name=GUI_PFX .. "show_selection_box", tooltip="Displays a visual box around your current selection area"}
        selection_box_table.add{type="button", caption="Refresh", name=GUI_PFX .. "refresh_circuit_networks", tooltip="Refresh the circuit network visualization"}

    local drop_down_table = mod_frame.add{type="table", column_count=4, name=GUI_PFX .. "drop_down_table"}
        drop_down_table.add{type="label", caption="Direction to copy:", tooltop="The direction pastes will be executed in. Use a custom tile paste override if you need finer control."}
        drop_down_table.add{type="drop-down", items={"North","East","South","West"}, selected_index=1, name = GUI_PFX .. "direction-to-copy"}
        drop_down_table.add{type="label", caption="Number of copies:", tooltip="How many copies of the area above will be made. Note that you will end up with 1 more copy than the number selected here (the original area)"}
        drop_down_table.add{type="textfield", name="number_of_copies", text=1, numeric=true}
        drop_down_table["number_of_copies"].style.left_padding = 8
        drop_down_table["number_of_copies"].style.right_padding = 8
        drop_down_table["number_of_copies"].style.horizontal_align = "right"
        drop_down_table["number_of_copies"].style.maximal_width = 100

    local button_control_table = mod_frame.add{type="table", column_count=3}
        button_control_table.add{type="button", name=GUI_PFX .. "restrict_selection_area_to_entities", caption="Shrink Selection Area", tooltip="Reduces the size of your selection area to include only the entities found in that area"}
        local get_selection_tool_button = button_control_table.add{type="button", name=GUI_PFX .. "get_selection_tool_button", caption="Get Selection Tool"}
        local copy_paste_start_button = button_control_table.add{type="button", name=GUI_PFX .. "issue_copy_pastes_button", caption="Start"}
        copy_paste_start_button.style.horizontal_align="right"
end

gui.clear_gui = function (player)
    local mod_button = mod_gui.get_button_flow(player)
    local mod_frame = mod_gui.get_frame_flow(player)
    if mod_button[GUI_PFX .. "main-button"] then
        mod_button[GUI_PFX .. "main-button"].destroy()
    end
    if mod_frame[GUI_PFX .. "control-window"] then
        mod_frame[GUI_PFX .. "control-window"].destroy()
    end
    if mod_frame[GUI_PFX .. "advanced_view_pane"] then
        mod_frame[GUI_PFX .. "advanced_view_pane"].destroy()
    end
    -- Clear any existing selection box rendering
    gui.clear_selection_box(player)
    gui.clear_circuit_connections(player)
end

-- Function to render the selection box
gui.render_selection_box = function(player)
    local selection_box_table = mod_gui.get_frame_flow(player)[GUI_PFX .. "control-window"][GUI_PFX .. "selection_box_table"]
    show =  selection_box_table and selection_box_table[GUI_PFX .. "show_selection_box"].state
    if not show then
       gui.clear_selection_box(player)
       gui.clear_circuit_connections(player)
       return
    end

    local coord_table = mod_gui.get_frame_flow(player)[GUI_PFX .. "control-window"][GUI_PFX .. "coordinate-table"]
    if not coord_table then return end

    local left_top_x = tonumber(coord_table["left_top_x"].text)
    local left_top_y = tonumber(coord_table["left_top_y"].text)
    local right_bottom_x = tonumber(coord_table["right_bottom_x"].text)
    local right_bottom_y = tonumber(coord_table["right_bottom_y"].text)

    -- Clear existing selection box first
    gui.clear_selection_box(player)

    -- Only render if all coordinates are valid numbers and form a valid rectangle
    if left_top_x and left_top_y and right_bottom_x and right_bottom_y and
       (left_top_x ~= right_bottom_x or left_top_y ~= right_bottom_y) and
       left_top_x < right_bottom_x and left_top_y < right_bottom_y then

        local surface = player.surface

        -- Create rendering objects for the selection box (visual only, no entities)
        local render_objects = {}

        -- Use only the rendering API - no actual entities that could interfere with dragging
        if rendering then
            -- Draw rectangle outline only
            table.insert(render_objects, rendering.draw_rectangle{
                color = {r = 0, g = .4, b = .8, a = 0.8},
                width = 8,
                filled = false,
                left_top = {left_top_x, left_top_y},
                right_bottom = {right_bottom_x, right_bottom_y},
                surface = surface,
                players = {player},
                draw_on_ground = true,
                visible = true
            })
        end

        -- Store render objects for cleanup
        storage.selection_boxes = storage.selection_boxes or {}
        storage.selection_boxes[player.index] = render_objects
    end
    gui.render_circuit_connections(player)
end

-- Function to clear the selection box
gui.clear_selection_box = function(player)
    if storage.selection_boxes and storage.selection_boxes[player.index] then
        for _, render_object in pairs(storage.selection_boxes[player.index]) do
            if render_object.valid then
                render_object.destroy()
            end
        end
        storage.selection_boxes[player.index] = nil
    end
end


-- Function to render circuit network connections
gui.render_circuit_connections = function(player)
    local coord_table = mod_gui.get_frame_flow(player)[GUI_PFX .. "control-window"][GUI_PFX .. "coordinate-table"]
    if not coord_table then return end

    -- Parse coordinates
    local coords = {}
    for _, key in ipairs({"left_top_x", "left_top_y", "right_bottom_x", "right_bottom_y"}) do
        coords[key] = tonumber(coord_table[key].text)
        if not coords[key] then return end
    end

    -- Validate rectangle
    if coords.left_top_x >= coords.right_bottom_x or coords.left_top_y >= coords.right_bottom_y then
        return
    end

    gui.clear_circuit_connections(player)

    local surface = player.surface
    local area = {{coords.left_top_x, coords.left_top_y}, {coords.right_bottom_x, coords.right_bottom_y}}
    local area_width = coords.right_bottom_x - coords.left_top_x
    local area_height = coords.right_bottom_y - coords.left_top_y

    -- Get copy settings
    local drop_down_table = mod_gui.get_frame_flow(player)[GUI_PFX .. "control-window"][GUI_PFX .. "drop_down_table"]
    if not drop_down_table then return end

    local copy_direction = drop_down_table[GUI_PFX .. "direction-to-copy"].selected_index
    local number_of_copies = 1

    -- Get tile paste override settings
    local tile_paste_x, tile_paste_y = area_width, area_height
    local use_tile_paste_override = false

    local advanced_view_pane = mod_gui.get_frame_flow(player)[GUI_PFX .. "advanced_view_pane"]
    if advanced_view_pane then
        local override_table = advanced_view_pane[GUI_PFX .. "advanced_tile_paste_override_table"]
        if override_table and override_table[GUI_PFX .. "advanced_tile_paste_override_checkbox"].state then
            use_tile_paste_override = true
            tile_paste_x = tonumber(override_table[GUI_PFX .. "advanced_tile_paste_x"].text) or area_width
            tile_paste_y = tonumber(override_table[GUI_PFX .. "advanced_tile_paste_y"].text) or area_height
        end
    end

    -- Helper function to calculate clone offset
    local function get_clone_offset(copy_num)
        if use_tile_paste_override then
            return tile_paste_x * copy_num, tile_paste_y * copy_num
        end

        local offsets = {
            [1] = {0, -area_height * copy_num}, -- North
            [2] = {area_width * copy_num, 0},   -- East
            [3] = {0, area_height * copy_num},   -- South
            [4] = {-area_width * copy_num, 0}   -- West
        }
        return table.unpack(offsets[copy_direction] or {0, 0})
    end

    -- Helper function to check if connection would work in clones
    local function would_clone_successfully(entity, target_entity)
        local offset_x = entity.position.x - target_entity.position.x
        local offset_y = entity.position.y - target_entity.position.y

        for copy_num = 1, number_of_copies do
            local clone_offset_x, clone_offset_y = get_clone_offset(copy_num)
            if clone_offset_x == 0 and clone_offset_y == 0 then
                return false
            end
            local target_clone_pos = {
                x = entity.position.x + clone_offset_x - offset_x,
                y = entity.position.y + clone_offset_y - offset_y
            }

            if surface.find_entity({name=target_entity.name, quality=target_entity.quality}, target_clone_pos) then
                return true
            end
        end
        return false
    end

    -- Find and process circuit connections
    local entity_pair_connections = {}
    local wire_types = {
        [defines.wire_connector_id.circuit_red] = "has_red",
        [defines.wire_connector_id.circuit_green] = "has_green"
    }

    for _, entity in pairs(surface.find_entities(area)) do
        if entity.valid then
            for wire_id, wire_key in pairs(wire_types) do
                local connector = entity.get_wire_connector(wire_id)
                if connector then
                    for _, connection in pairs(connector.connections) do
                        local target = connection.target.owner
                        if target and target.valid and
                           not (target.position.x >= coords.left_top_x and target.position.x <= coords.right_bottom_x and
                                target.position.y >= coords.left_top_y and target.position.y <= coords.right_bottom_y) and
                           would_clone_successfully(entity, target) then

                            -- Create unique pair key
                            local id1, id2 = entity.unit_number or 0, target.unit_number or 0
                            local pair_key = string.format("%d_%d", math.min(id1, id2), math.max(id1, id2))

                            if not entity_pair_connections[pair_key] then
                                entity_pair_connections[pair_key] = {
                                    entity1 = entity,
                                    entity2 = target,
                                    has_red = false,
                                    has_green = false
                                }
                            end
                            entity_pair_connections[pair_key][wire_key] = true
                        end
                    end
                end
            end
        end
    end

    -- Render connections
    local render_objects = {}
    local wire_configs = {
        red = {color = {r=1, g=0, b=0, a=0.8}, offset_mult = 1},
        green = {color = {r=0, g=1, b=0, a=0.8}, offset_mult = -1}
    }

    for _, conn in pairs(entity_pair_connections) do
        local pos1, pos2 = conn.entity1.position, conn.entity2.position
        local dx, dy = pos2.x - pos1.x, pos2.y - pos1.y
        local length = math.sqrt(dx * dx + dy * dy)

        if length > 0 then
            local perp_x, perp_y = -dy / length * 0.15, dx / length * 0.15
            local has_both = conn.has_red and conn.has_green

            -- Draw wires
            for wire_type, config in pairs(wire_configs) do
                if conn["has_" .. wire_type] then
                    local offset = has_both and config.offset_mult or 0
                    local from = {x = pos1.x + perp_x * offset, y = pos1.y + perp_y * offset}
                    local to = {x = pos2.x + perp_x * offset, y = pos2.y + perp_y * offset}

                    table.insert(render_objects, rendering.draw_line{
                        color = config.color,
                        width = 3,
                        from = from,
                        to = to,
                        surface = surface,
                        players = {player},
                        draw_on_ground = false,
                        visible = true
                    })
                end
            end

            -- Draw connection points
            local point_color = has_both and {r=1, g=0.5, b=0, a=0.8} or
                               (conn.has_red and wire_configs.red.color or wire_configs.green.color)
            local radius = has_both and 0.25 or 0.2

            for _, pos in ipairs({pos1, pos2}) do
                table.insert(render_objects, rendering.draw_circle{
                    color = point_color,
                    radius = radius,
                    filled = true,
                    target = pos,
                    surface = surface,
                    players = {player},
                    draw_on_ground = false,
                    visible = true
                })
            end
        end
    end

    -- Store render objects
    storage.circuit_connections = storage.circuit_connections or {}
    storage.circuit_connections[player.index] = render_objects
end

-- Function to clear circuit network connections
gui.clear_circuit_connections = function(player)
    if storage.circuit_connections and storage.circuit_connections[player.index] then
        for _, render_object in pairs(storage.circuit_connections[player.index]) do
            if render_object.valid then
                render_object.destroy()
            end
        end
        storage.circuit_connections[player.index] = nil
    end
end


return gui